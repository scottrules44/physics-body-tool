{"ast":null,"code":"/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function tableRow(state, node, parent) {\n  const siblings = parent ? parent.children : undefined; // Generate a body row when without parent.\n\n  const rowIndex = siblings ? siblings.indexOf(node) : 1;\n  const tagName = rowIndex === 0 ? 'th' : 'td';\n  const align = parent && parent.type === 'table' ? parent.align : undefined;\n  const length = align ? align.length : node.children.length;\n  let cellIndex = -1;\n  /** @type {Array<ElementContent>} */\n\n  const cells = [];\n\n  while (++cellIndex < length) {\n    // Note: can also be undefined.\n    const cell = node.children[cellIndex];\n    /** @type {Properties} */\n\n    const properties = {};\n    const alignValue = align ? align[cellIndex] : undefined;\n\n    if (alignValue) {\n      properties.align = alignValue;\n    }\n    /** @type {Element} */\n\n\n    let result = {\n      type: 'element',\n      tagName,\n      properties,\n      children: []\n    };\n\n    if (cell) {\n      result.children = state.all(cell);\n      state.patch(cell, result);\n      result = state.applyData(node, result);\n    }\n\n    cells.push(result);\n  }\n  /** @type {Element} */\n\n\n  const result = {\n    type: 'element',\n    tagName: 'tr',\n    properties: {},\n    children: state.wrap(cells, true)\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}","map":{"version":3,"names":["tableRow","state","node","parent","siblings","children","undefined","rowIndex","indexOf","tagName","align","type","length","cellIndex","cells","cell","properties","alignValue","result","all","patch","applyData","push","wrap"],"sources":["/Users/scottharrison/ownCloud/Desktop/cached projects/web-physic-body-editor/physics-body-tool/node_modules/mdast-util-to-hast/lib/handlers/table-row.js"],"sourcesContent":["/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function tableRow(state, node, parent) {\n  const siblings = parent ? parent.children : undefined\n  // Generate a body row when without parent.\n  const rowIndex = siblings ? siblings.indexOf(node) : 1\n  const tagName = rowIndex === 0 ? 'th' : 'td'\n  const align = parent && parent.type === 'table' ? parent.align : undefined\n  const length = align ? align.length : node.children.length\n  let cellIndex = -1\n  /** @type {Array<ElementContent>} */\n  const cells = []\n\n  while (++cellIndex < length) {\n    // Note: can also be undefined.\n    const cell = node.children[cellIndex]\n    /** @type {Properties} */\n    const properties = {}\n    const alignValue = align ? align[cellIndex] : undefined\n\n    if (alignValue) {\n      properties.align = alignValue\n    }\n\n    /** @type {Element} */\n    let result = {type: 'element', tagName, properties, children: []}\n\n    if (cell) {\n      result.children = state.all(cell)\n      state.patch(cell, result)\n      result = state.applyData(node, result)\n    }\n\n    cells.push(result)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'tr',\n    properties: {},\n    children: state.wrap(cells, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,QAAT,CAAkBC,KAAlB,EAAyBC,IAAzB,EAA+BC,MAA/B,EAAuC;EAC5C,MAAMC,QAAQ,GAAGD,MAAM,GAAGA,MAAM,CAACE,QAAV,GAAqBC,SAA5C,CAD4C,CAE5C;;EACA,MAAMC,QAAQ,GAAGH,QAAQ,GAAGA,QAAQ,CAACI,OAAT,CAAiBN,IAAjB,CAAH,GAA4B,CAArD;EACA,MAAMO,OAAO,GAAGF,QAAQ,KAAK,CAAb,GAAiB,IAAjB,GAAwB,IAAxC;EACA,MAAMG,KAAK,GAAGP,MAAM,IAAIA,MAAM,CAACQ,IAAP,KAAgB,OAA1B,GAAoCR,MAAM,CAACO,KAA3C,GAAmDJ,SAAjE;EACA,MAAMM,MAAM,GAAGF,KAAK,GAAGA,KAAK,CAACE,MAAT,GAAkBV,IAAI,CAACG,QAAL,CAAcO,MAApD;EACA,IAAIC,SAAS,GAAG,CAAC,CAAjB;EACA;;EACA,MAAMC,KAAK,GAAG,EAAd;;EAEA,OAAO,EAAED,SAAF,GAAcD,MAArB,EAA6B;IAC3B;IACA,MAAMG,IAAI,GAAGb,IAAI,CAACG,QAAL,CAAcQ,SAAd,CAAb;IACA;;IACA,MAAMG,UAAU,GAAG,EAAnB;IACA,MAAMC,UAAU,GAAGP,KAAK,GAAGA,KAAK,CAACG,SAAD,CAAR,GAAsBP,SAA9C;;IAEA,IAAIW,UAAJ,EAAgB;MACdD,UAAU,CAACN,KAAX,GAAmBO,UAAnB;IACD;IAED;;;IACA,IAAIC,MAAM,GAAG;MAACP,IAAI,EAAE,SAAP;MAAkBF,OAAlB;MAA2BO,UAA3B;MAAuCX,QAAQ,EAAE;IAAjD,CAAb;;IAEA,IAAIU,IAAJ,EAAU;MACRG,MAAM,CAACb,QAAP,GAAkBJ,KAAK,CAACkB,GAAN,CAAUJ,IAAV,CAAlB;MACAd,KAAK,CAACmB,KAAN,CAAYL,IAAZ,EAAkBG,MAAlB;MACAA,MAAM,GAAGjB,KAAK,CAACoB,SAAN,CAAgBnB,IAAhB,EAAsBgB,MAAtB,CAAT;IACD;;IAEDJ,KAAK,CAACQ,IAAN,CAAWJ,MAAX;EACD;EAED;;;EACA,MAAMA,MAAM,GAAG;IACbP,IAAI,EAAE,SADO;IAEbF,OAAO,EAAE,IAFI;IAGbO,UAAU,EAAE,EAHC;IAIbX,QAAQ,EAAEJ,KAAK,CAACsB,IAAN,CAAWT,KAAX,EAAkB,IAAlB;EAJG,CAAf;EAMAb,KAAK,CAACmB,KAAN,CAAYlB,IAAZ,EAAkBgB,MAAlB;EACA,OAAOjB,KAAK,CAACoB,SAAN,CAAgBnB,IAAhB,EAAsBgB,MAAtB,CAAP;AACD"},"metadata":{},"sourceType":"module"}